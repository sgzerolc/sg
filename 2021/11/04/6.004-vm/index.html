<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="17 virtual memory  Virtual memory Virtual machine   18 virtualizing the processor  build a VM 进程如何复用cpu？ interrupts to time-sharing exception handling Communicate with os   19 devices and interrupt">
<meta property="og:type" content="article">
<meta property="og:title" content="4 virtual memory">
<meta property="og:url" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/index.html">
<meta property="og:site_name" content="steins gate zero">
<meta property="og:description" content="17 virtual memory  Virtual memory Virtual machine   18 virtualizing the processor  build a VM 进程如何复用cpu？ interrupts to time-sharing exception handling Communicate with os   19 devices and interrupt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc1.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc2.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc3.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc4.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc5.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc6.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc7.png">
<meta property="article:published_time" content="2021-11-04T00:00:00.000Z">
<meta property="article:modified_time" content="2024-06-30T21:09:04.506Z">
<meta property="article:author" content="Sam Li">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/sc1.png">
    
    
      
        
          <link rel="shortcut icon" href="/sg/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/sg/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/sg/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>4 virtual memory</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/sg/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/sg/">Home</a></li><!--
     --><!--
       --><li><a href="/sg/about/">About</a></li><!--
     --><!--
       --><li><a href="/sg/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/sg/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/sg/CV/">CV</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/sg/2021/11/07/dark/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/sg/2021/11/04/SC_programming/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&text=4 virtual memory"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&is_video=false&description=4 virtual memory"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=4 virtual memory&body=Check out this article: https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&name=4 virtual memory&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&t=4 virtual memory"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">17 virtual memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">Virtual memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.1.</span> <span class="toc-text">&gt; MMU:translate VA to PA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.2.</span> <span class="toc-text">&gt; Where to store page map:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.3.</span> <span class="toc-text">&gt; sum up: MMU address translation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Virtual machine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">18 virtualizing the processor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">build a VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">进程如何复用cpu？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">interrupts to time-sharing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">exception handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.5.</span> <span class="toc-text">Communicate with os</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">19 devices and interrupts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">Interrupt-based asynch I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">Implementations of ReadKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">Time-sharing can’t meet with ddl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text">the need for real time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text">Real-time scenarios</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.1.</span> <span class="toc-text">&gt; Stragegy0:  first-come-first-served scenario.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.2.</span> <span class="toc-text">&gt; Strategy1: “nonpreemptive” &#x2F; “weak” priority system.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.3.</span> <span class="toc-text">&gt; Strategy2: the need for preemption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.4.</span> <span class="toc-text">&gt; recurring interrupts</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        4 virtual memory
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Sam Li</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-11-04T00:00:00.000Z" itemprop="datePublished">2021-11-04</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/sg/categories/computer-architecture/">computer architecture</a> › <a class="category-link" href="/sg/categories/computer-architecture/6-004-computation-structures/">6.004 computation structures</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <div class="toc">
<!-- toc -->
<ul>
<li><a href="#17-virtual-memory">17 virtual memory</a>
<ul>
<li><a href="#virtual-memory">Virtual memory</a></li>
<li><a href="#virtual-machine">Virtual machine</a></li>
</ul>
</li>
<li><a href="#18-virtualizing-the-processor">18 virtualizing the processor</a>
<ul>
<li><a href="#build-a-vm">build a VM</a></li>
<li><a href="#jin-cheng-ru-he-fu-yong-cpu">进程如何复用cpu？</a></li>
<li><a href="#interrupts-to-time-sharing">interrupts to time-sharing</a></li>
<li><a href="#exception-handling">exception handling</a></li>
<li><a href="#communicate-with-os">Communicate with os</a></li>
</ul>
</li>
<li><a href="#19-devices-and-interrupts">19 devices and interrupts</a>
<ul>
<li><a href="#interrupt-based-asynch-i-o">Interrupt-based asynch I/O</a></li>
<li><a href="#implementations-of-readkey">Implementations of ReadKey</a></li>
<li><a href="#time-sharing-can-t-meet-with-ddl">Time-sharing can’t meet with ddl</a></li>
<li><a href="#the-need-for-real-time">the need for real time</a></li>
<li><a href="#real-time-scenarios">Real-time scenarios</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h2><span id="17-virtual-memory">17 virtual memory</span><a href="#17-virtual-memory" class="header-anchor">¶</a></h2>
<p>Fact:DRAM accessing hard disk is much more slower(100,000) than cache accessing main main memory.</p>
<p>Problem: Enormous miss penalty of secondary storage</p>
<p>Solution/Goal: the miss rate should be very small compared to the rate of executing instructions.(decrease miss ratio)</p>
<p>Design policy:</p>
<ol>
<li>
<p>high associativity: avoid collisions between accesses</p>
</li>
<li>
<p>large block size: amortize the cost of miss over many future hits</p>
</li>
<li>
<p>Write-back strategy: separation of hardware and software.only update the contents of disk when data that’s changed in main memory needs to be replaced by data from other blocks of secondary storage.</p>
<blockquote>
<p>upside of long latencies: manage the organization of main memory and the accesses to secondary storage in software.</p>
<p>-&gt; handle hits in hw, misses in sw</p>
</blockquote>
</li>
</ol>
<h3><span id="virtual-memory">Virtual memory</span><a href="#virtual-memory" class="header-anchor">¶</a></h3>
<p>Fact: we only need to ensure the current working set of a program is actually resident in main memory. Locations not currently being used could live in secondary storage until needed.</p>
<p>Goal:</p>
<ul>
<li>
<p>Exploit locality on a large scale</p>
<ul>
<li>solution: MMU with single-level page map</li>
<li>optimizations
<ul>
<li>store in RAM</li>
<li>TLB</li>
</ul>
</li>
<li>Cache/VM interactions</li>
</ul>
</li>
<li>
<p>ease memory management, protect multiple contexts from each other.</p>
</li>
</ul>
<h4><span id="gt-mmu-translate-va-to-pa">&gt; MMU:translate VA to PA</span><a href="#gt-mmu-translate-va-to-pa" class="header-anchor">¶</a></h4>
<p>Solution: two part: VAtoPA + PageFault</p>
<ul>
<li>use hw(MMU) to implement VtoP, use sw(page fault exception handler of CPU) to handle exceptional cases</li>
</ul>
<blockquote>
<p>fact:  MMU maps virtual pages to physical pages. Cause a page fault if virtual page is not resident in physical memory.</p>
</blockquote>
<p>implementation: Paging/demand paging</p>
<p>Plan:</p>
<ol>
<li>
<p>All virtual pages in secondary storage, MMU empty.</p>
</li>
<li>
<p>map VA to PA</p>
<p>2.1 RAM-resident page</p>
<p>2.2 non-resident page: page fault</p>
<p>​	CPU switches execution to page fault handler, the handler allocates a physical page for VA loaded from hard disk, then adjusts the page map entry. If all physical pages are unavailable, it chooses an existing page to replace. Finally return control to program.</p>
</li>
<li>
<p>Working set incrementally loaded via page faults</p>
<p>problem: thrashing: programs constantly generate page faults, which causes the program run very slowly.</p>
</li>
</ol>
<p>Arithmetic: page map(v, m, p)</p>
<h4><span id="gt-where-to-store-page-map">&gt; Where to store page map:</span><a href="#gt-where-to-store-page-map" class="header-anchor">¶</a></h4>
<ol>
<li>
<p>store in RAM(main memory): RAM-resident page maps</p>
<blockquote>
<p>use a register, called the page map pointer, to hold the address of the page map array in main memory</p>
</blockquote>
<p>problem: each memory reference takes 2 accesses to physical memory</p>
</li>
<li>
<p>cache the page map entries: translation look-aside buffer: a special-purpose fully-associative cache</p>
<p>TLB(VA, PA)</p>
<blockquote>
<p>If the PPN is found by using the TLB, the access to main memory for the page table entry can be avoided.</p>
</blockquote>
<ul>
<li>
<p>Variations:</p>
<ul>
<li>Multi-level page map</li>
</ul>
<blockquote>
<p>The key idea is that the page map segments are in virtual memory, <em>i.e.</em>, they don’t all have to be resident at any given time. If the running application is only actively using a small portion of its virtual address space, we may only need a handful of pages to hold the page directory and the necessary page map segments.</p>
</blockquote>
<ul>
<li>paging the page map</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4><span id="gt-sum-up-mmu-address-translation">&gt; sum up: MMU address translation</span><a href="#gt-sum-up-mmu-address-translation" class="header-anchor">¶</a></h4>
<img src="/sg/2021/11/04/6.004-vm/sc1.png" class title="截屏2021-11-01 上午10.15.13">
<h3><span id="virtual-machine">Virtual machine</span><a href="#virtual-machine" class="header-anchor">¶</a></h3>
<p>Fact:</p>
<blockquote>
<p>context: a mapping of VA to PA</p>
</blockquote>
<ul>
<li>problem: timesharing among several programs,When new program starts, the context should be updated by flushing TLB which costs a lot.</li>
</ul>
<p>example: OS kernel/user</p>
<ul>
<li>
<p>Solution: perform rapid context-switching</p>
<ul>
<li>add a register to hold index of current context.</li>
<li>switch contexts: update context # and pageablePtr registers.</li>
</ul>
</li>
<li>
<p>Problem: use caches with Virtual memory</p>
<p>disign choice:</p>
<ol>
<li>Virtually-addressed cache</li>
<li>Physically-addressed cache</li>
<li>Overlapped operation</li>
</ol>
</li>
</ul>
<p>several part to consider: MMU time on HIT, flush cache after context switch</p>
<p>…to be continued this part</p>
<h2><span id="18-virtualizing-the-processor">18 virtualizing the processor</span><a href="#18-virtualizing-the-processor" class="header-anchor">¶</a></h2>
<p>回顾一下虚拟内存，简单来说它提供给每个运行的程序一个拥有计算机所有内存地址空间的幻想。它通过内存控制单元实现从虚拟地址到物理地址的转换，用虚拟地址查询页表，而用页表来记录物理地址，完成查询。</p>
<p>由于访问硬盘的延迟比主存储器（main memory）慢的多，通过TLB（一种缓存器）来记录活跃的虚拟地址到物理地址的转换。</p>
<h3><span id="build-a-vm">build a VM</span><a href="#build-a-vm" class="header-anchor">¶</a></h3>
<p>把正在运行的程序抽象成进程，一个进程包含它运行所需要的所有资源(CPU,I/O device, MMU,virtual address space)…</p>
<p>有一个特别的优先的进程叫kernel。OS为各种进程提供服务，比如访问文件中的数据，建立网络连接，管理UI。从不同用户模式的进程切换，OS需要保存现在运行的进程状态，保存在主存储器中或二级存储器中。</p>
<p>Problem: share one physical machine between all the virtual machines.  As if each process was running on its own “virtual machine” that works independently of other virtual machines for other processes.(OS’s job)</p>
<p>Fact: one VM for each process</p>
<ul>
<li>OS把外接设备都抽象成服务，为每个进程提供独立的虚拟机，周期性地从一个进程转换到下一个进程。</li>
<li>外接设备包含一个定时器触发周期性的CPU中断，提供非易失性存储的二级存储器，连接外部设备的USB接口，视频监控器，键盘，鼠标等用户界面服务。</li>
<li>抽象包括窗口，访问磁盘内的文件，网络传输等。OS通过supervisor calls(SVCs)配置和控制虚拟服务。</li>
</ul>
<blockquote>
<p>The process state includes</p>
<ul>
<li>the hardware state of the CPU, <em>i.e.</em>, the values in the registers and program counter.</li>
<li>the contents of the process’ virtual address space, including code, data values, the stack, and data objects dynamically allocated from the heap. Under the management of the MMU, this portion of the state can be resident in main memory or can reside in secondary storage.</li>
<li>the hardware state of the MMU, which, as we saw earlier, depends on the context-number and page-directory registers. Also included are the pages allocated for the hierarchical page map.</li>
<li>additional information about the process’ input and output activities, such as where it has reached in reading or writing files in the file system, the status and buffers associated with open network connections, pending events from the user interface (<em>e.g.</em>, keyboard characters and mouse clicks), and so on.</li>
</ul>
</blockquote>
<h3><span id="jin-cheng-ru-he-fu-yong-cpu">进程如何复用cpu？</span><a href="#jin-cheng-ru-he-fu-yong-cpu" class="header-anchor">¶</a></h3>
<p>time-multiplexing of the cpu = timesharing</p>
<p>OS从运行进程0到运行进程1：</p>
<img src="/sg/2021/11/04/6.004-vm/sc2.png" class title="截屏2021-11-02 上午1.06.21">
<ul>
<li>运行进程0 -&gt; 停止运行0，将控制转移回OS kernel，保存当前地址（PC+4）-&gt; 保存进程0的状态并且加载进程1的状态 -&gt; 回到进程1 -&gt; 运行进程1。</li>
<li>第2步和第4步是不同的trap handler。</li>
</ul>
<h3><span id="interrupts-to-time-sharing">interrupts to time-sharing</span><a href="#interrupts-to-time-sharing" class="header-anchor">¶</a></h3>
<p>中断处理:handler</p>
<ul>
<li>
<p>Hardware</p>
<p>Timer interrupts:  the periodic interrupt from the external timer device.</p>
<p>how the interrupt hardware in the Beta works?</p>
<blockquote>
<p>it saves the PC+4 of the interrupted user-mode program in the XP register and sets the program counter to some predetermined value that depends on which external interrupt happened.</p>
</blockquote>
</li>
<li>
<p>software: beta interrupt handling</p>
<ul>
<li>
<p>保存状态到寄存器中（在os是叫UserMState的数据结构，在main memory中存储CPU的寄存器）-&gt; C程式处理exception -&gt;重装寄存器内保存的状态  -&gt; 回到原来的地址（Reg[XP]-4)</p>
</li>
<li>
<p>Where to find handlers</p>
<ul>
<li>Beta scheme: wire in a low-memory address for each exception handler entry point</li>
<li>Table of handler addresses</li>
</ul>
</li>
<li>
<p>问题：不是很懂中断对用户程序是透明的？或许是指用户程序能够访问中断改变的变量/状态。</p>
<blockquote>
<p>Since the process state is saved and restored during an interrupt, interrupts are transparent to the running user-mode program.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Example: timer interrupt handler</p>
<ul>
<li>
<p>设定：os maintains current time of day count in response to clock events.There are program A and clock handler.</p>
</li>
<li>
<p>目标是用时间中断器来更新os中记录现在时间的值。定时器定期中断用户模式程序，以在操作系统中运行时钟中断处理程序代码，然后继续用户模式程序的运行。对A来说，中断仿佛没有发生。如果A需要访问时间，则需要向os做出提出相应的服务要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Handler(C)</span><br><span class="line">long TimeOfDay;</span><br><span class="line">Struct Mstate &#123;&#125; UserMstate;</span><br><span class="line">Clock_Handler()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//Interrupt stub(assymbly)</span><br><span class="line">Clock_h:</span><br><span class="line">	save the values of all registers into the UserMState;</span><br><span class="line">	set up the kernel-mode stack;</span><br><span class="line">	call clock_handler;</span><br><span class="line">	reload registers;</span><br><span class="line">	decrement the XP register value;</span><br><span class="line">	return to the app;</span><br></pre></td></tr></table></figure>
<img src="/sg/2021/11/04/6.004-vm/sc3.png" class title="截屏2021-11-02 上午10.46.46">
</li>
</ul>
</li>
<li>
<p>Scheduler: simple timesharing scheduler</p>
<ul>
<li>
<p>设定：UserMState, process control block of each process(process table), index of current process</p>
</li>
<li>
<p>怎样运行一个新的时间共享的进程？</p>
<ul>
<li>
<p>scheduler通过保存现在进程的状态，改变索引值为进入下一个进程准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scheduler()&#123;</span><br><span class="line">  proctbl[cur].state = UserMState;</span><br><span class="line">  cur = (cur+<span class="number">1</span>)%N;</span><br><span class="line">  UserMState = proctbl[cur].state; <span class="comment">//install state</span></span><br><span class="line">  LoadUserContext(....PageMap); <span class="comment">//install context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Time-sharing story in os</p>
<ul>
<li>
<p>Timer 中断正在运行的用户模式程序并开始执行clock handler代码。clock handler先保存现在的进程状态到相关的数据结构中然后调用scheduler。scheduler将暂时保存的进程状态转移到process table中，而之后调用的scheduler会为下一个运行的进程保存相关的状态到暂时存放的地址，clock handler重新加载寄存器保存的状态继续运行下一个进程，这样循环下去。</p>
</li>
<li>
<p>设定: supervisor mode bit：1时不允许中断，0时允许。kernel mode is set 1; user mode is set 0.</p>
<ul>
<li>中断不能同时运行，一次只能运行一次。设置监控位保证这一点。由于中断发生会改变进程状态，这样是为了确保不会覆盖进程的状态到寄存器（UserMState）中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="exception-handling">exception handling</span><a href="#exception-handling" class="header-anchor">¶</a></h3>
<p>problem: how to deal with “illegal” opcodes?</p>
<p>…跳过了硬件，汇编的部分</p>
<h3><span id="communicate-with-os">Communicate with os</span><a href="#communicate-with-os" class="header-anchor">¶</a></h3>
<p>Problem: how user-mode programs communicate with OS code?</p>
<p>当os在运行其他进程时，用户程序该如何将控制转移回os？</p>
<p>Solution:</p>
<ul>
<li>abstraction: Use supervisor calls with args in registers</li>
<li>Implementation: use illegal instructions to cause an exception, and OS recognize the instruction as a user-mode SVCs</li>
</ul>
<p>…跳过了汇编部分</p>
<h2><span id="19-devices-and-interrupts">19 devices and interrupts</span><a href="#19-devices-and-interrupts" class="header-anchor">¶</a></h2>
<p>Problem 1: how the OS interacts with the devices themselves?</p>
<p>Problem 2: how supervisor calls access the kernel buffers in response to requests from user-mode processes?</p>
<h3><span id="interrupt-based-asynch-i-o">Interrupt-based asynch I/O</span><a href="#interrupt-based-asynch-i-o" class="header-anchor">¶</a></h3>
<p>操作系统中有很多输入/输出设备，以键盘输入为例，用户在键盘上打字，引起键盘向cpu发起中断请求。中断停止当前程序的运行而执行这个特别的输入输出事件。当内核中的缓存用完后会发生什么？</p>
<p>早先的处理方式是丢弃收到的键盘输入的字符，提示用户之前输入的已作废。</p>
<p>后来用户模式的程序执行ReadKey() SVC，要求OS返回下一个字母到R0寄存器中，然后遵循SVC继续执行指令。</p>
<blockquote>
<p>ReadKey() SVC: a blocking I/O request.</p>
<p>当没有字符返回时不执行直到有可用的结果返回。</p>
<p>the program assumes that when the SVC returns, the next character is in R0. If there isn’t (yet) a character to be returned, execution should be “blocked”, <em>i.e.</em>, suspended, until such time that a character is available.</p>
<p>Non-blocking I/O request: return immediately with both a status flag and a result.</p>
<p>当没有字符返回时仍然执行指令，在之后重新发起请求。</p>
</blockquote>
<ul>
<li>
<p>Operation: no attention to keyboard during normal operation</p>
<ul>
<li>
<p>Event-driven approach</p>
<p>用户模式程序和键盘并没有直接互动，而是通过事件驱动方法，设备当需要处理输入时通过中断向操作系统发出信号。这样把责任分离的好处是减少操作系统不停地检查是否有未完成的I/O操作</p>
</li>
</ul>
</li>
<li>
<p>The interrupt-driven OS interactions with I/O devices are completely transparent to user programs.</p>
</li>
<li>
<p>Example: keyboard interrupt handler</p>
<ul>
<li>sketch: cpu needs access device status and data</li>
<li>approach:Memory-mapper I/O: a portion of the kernel address space is devoted to servicing I/O devices.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Device</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> Flag, Data;</span><br><span class="line">&#125;keyboard;</span><br><span class="line"></span><br><span class="line">keyHit_h()&#123;</span><br><span class="line">  Buffer[inptr] = keyboard.Data;</span><br><span class="line">  inptr = (...)...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现实中更复杂：</p>
<p>键盘处理还需要识别键的状态是按下还是释放，然后将字符转换成ASCII码，并且需要处理特殊的按键组合。</p>
</li>
</ul>
<h3><span id="implementations-of-readkey">Implementations of ReadKey</span><a href="#implementations-of-readkey" class="header-anchor">¶</a></h3>
<p>Goal: the associated supervisor call that lets user programs read characters.</p>
<p>Attempt1: 直接写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadKey_h()&#123;</span><br><span class="line">  <span class="type">int</span> kbdnum = ProcTbl[Cur].DPYNum;</span><br><span class="line">  <span class="keyword">while</span> (BufferEmpty(kbdnum))&#123;</span><br><span class="line">    <span class="comment">/* busy wait loop*/</span></span><br><span class="line">  &#125;</span><br><span class="line">	UserMState.Reqs[<span class="number">0</span>] = ReadInputBuffer (kbdnum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	kbdnum:keyboard num;proctbl: process table</p>
<ul>
<li>
<p>Problem：kernel/supervisor mode can’t be interrupted.</p>
<blockquote>
<p>the SVC handler is running with the supervisor bit (PC[31]) set to 1, disabling interrupts.</p>
</blockquote>
<ul>
<li>
<p>such that the buffer never gets filled.</p>
</li>
<li>
<p>陷入死循环</p>
</li>
</ul>
</li>
</ul>
<p>Attempt2: fix the looping problem by adding code to subtract 4 from the saved value of the XP register before returning</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReadKey_h()&#123;</span><br><span class="line">  <span class="type">int</span> kbdnum = ProcTbl[Cur].DPYNum;</span><br><span class="line">	<span class="keyword">if</span> (BufferEmpty(kbdnum))&#123;</span><br><span class="line">	<span class="comment">/* busy wait loop*/</span></span><br><span class="line">		UserMState.Regs[XP] = UserMState.Regs [XP]<span class="number">-4</span> ;</span><br><span class="line">    Scheduler(); <span class="comment">//attempt3</span></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">	UserMState.Reqs[<span class="number">0</span>] = ReadInputBuffer (kbdnum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>和Attempt1的区别是：</p>
<ul>
<li>
<p>执行循环的方式：当中断推出时，操作系统通过跳到xp继续执行用户模式的指令。通过改变这一地址来循环发出中断。（汇编的常见循环方式？我认为）</p>
<blockquote>
<p>When the handler exits, the OS will resume execution of the user-mode program by reloading the registers and then executing a JMP(XP), which would normally then execute the instruction <em>following</em> the SVC instruction.</p>
</blockquote>
</li>
<li>
<p>ReadKey() SVC 进入用户模式</p>
</li>
</ul>
</li>
<li>
<p>Problem: waste its time-slice waiting for next keystroke</p>
</li>
</ul>
<p>Attempt3: 利用等待的时间执行别的程序，通过循环调度的方式最后回到ReadKey() SVC</p>
<blockquote>
<p>The call to Scheduler() suspends execution of the current process and arranges for the next process to run when the handler exits. (Round-robin scheduling).</p>
<p>建立在以下事实上：</p>
<p>Fact: the time slices for each process are small enough that one round of process execution happens more quickly than the time between two typed characters</p>
</blockquote>
<ul>
<li>Time-sharing 在此场景下的意义：
<ul>
<li>进行计算密集型的程序时由于分隔时间(cycles)过短，time-sharing可能会增加额外的成本在进程交换（context-switching, scheduling）上。</li>
<li>当有很多个程序需要执行时，分隔时间增加，time-sharing才增加了效率</li>
</ul>
</li>
<li>进一步的提高效率：将进程的状态（活跃/等待）记录到进程的数据中，通过优先执行活跃的程序减少等待的时间。
<ul>
<li>unix系统中sleep, wakeup可以改变进程的相应状态</li>
</ul>
</li>
</ul>
<p>Attemp4: “进一步”的实现:no CPU cycles are wasted on useless activity.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ReadKey_h()&#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">if</span> (BufferEmpty(kbdnum))&#123;</span><br><span class="line">		User.Regs[XP] = User.Regs&#123;XP] - <span class="number">4</span>;</span><br><span class="line">		sleep(kbdnum);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;... &#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(status s) &#123;</span><br><span class="line">		ProcTbI[Cur].status = s;</span><br><span class="line">		Scheduler();</span><br><span class="line">&#125;</span><br><span class="line">Scheduler)&#123;</span><br><span class="line">		<span class="keyword">while</span> (ProcTbIfi].status != <span class="number">0</span>) &#123;</span><br><span class="line">				i=(i+<span class="number">1</span>)%N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KeyHit_h()&#123;</span><br><span class="line">  ...</span><br><span class="line">  writeBuffer(kbdnum, key);</span><br><span class="line">	wakeup(kbdnum);</span><br><span class="line">  ...</span><br><span class="line">)  </span><br><span class="line">wakeup(status s) &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ProcTbli].status == s)</span><br><span class="line">				ProcTbli].status = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The effect is that once a process goes to sleep() WAITING for an event, it’s not considered for execution again until the event occurs and wakeup() marks the process as ACTIVE.</p>
</blockquote>
<p>Example: which handler &amp; os? 像个解谜游戏。根据handler和os的特点来排除。</p>
<h3><span id="time-sharing-can-t-meet-with-ddl">Time-sharing can’t meet with ddl</span><a href="#time-sharing-can-t-meet-with-ddl" class="header-anchor">¶</a></h3>
<p>Problem: asynchronous world.</p>
<p>Solution: I/O: separate “event handling” from “event processing”.</p>
<ul>
<li>Downside: the need for real-time: can’t predict completion time, therefore can’t deal with real-time system</li>
<li>Example: ESC on cars,需要实时计算各种因素才能准确刹车。而这是时间分享系统不能做到的</li>
</ul>
<blockquote>
<p>Time-sharing system: 在单个硬件系统上通过快速在进程间切换伪造并行的假象，为每个程序提供了在独立的虚拟机上运行的幻想。</p>
<p>downside: processing throughput is more variable</p>
</blockquote>
<h3><span id="the-need-for-real-time">the need for real time</span><a href="#the-need-for-real-time" class="header-anchor">¶</a></h3>
<ul>
<li>
<p>what’s the largest L such that Lmax+S=D?</p>
<blockquote>
<p>Measure of performance in a real-time system: interrupt latency L,the amount of time that elapses between a request to run some code and when that code actually starts executing.</p>
</blockquote>
</li>
</ul>
<img src="/sg/2021/11/04/6.004-vm/sc4.png" class title="截屏2021-11-04 上午12.10.58">
<ul>
<li>
<p>What factors contribute to interrupt latency?</p>
<ul>
<li>
<p>关心这个问题的原因在于实现最小化中断延迟以在期限时间完成程序运行的目标。所以我们需要知道导致延迟的原因然后减小延迟。</p>
</li>
<li>
<p>state save, context switch</p>
<blockquote>
<p>While handling an interrupt:it takes times to save the process state, switch to the kernel context, and dispatch to the correct interrupt handler.</p>
</blockquote>
</li>
<li>
<p>periods of un-interruptability</p>
<ul>
<li>Long,uninterruptable instructions</li>
<li>explicitly disabled periods: interrupt handler in kernel mode</li>
</ul>
</li>
<li>
<p>to bound and minimize interrupt latency by all means</p>
<blockquote>
<p>We’ll do this by optimizing the cost of taking an interrupt and dispatching to the correct handler code. We’ll avoid instructions whose execution time is data dependent. And we’ll work to minimize the time spent in kernel mode.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3><span id="real-time-scenarios">Real-time scenarios</span><a href="#real-time-scenarios" class="header-anchor">¶</a></h3>
<p>scenario: scheduling of multiple devices: long-running handlers have a huge impact on the worst-case latency seen by the other devices.</p>
<h4><span id="gt-stragegy0-first-come-first-served-scenario">&gt; Stragegy0:  first-come-first-served scenario.</span><a href="#gt-stragegy0-first-come-first-served-scenario" class="header-anchor">¶</a></h4>
<p>Problems: reducing the worst-case latencies</p>
<h4><span id="gt-strategy1-nonpreemptive-weak-priority-system">&gt; Strategy1: “nonpreemptive” / “weak” priority system.</span><a href="#gt-strategy1-nonpreemptive-weak-priority-system" class="header-anchor">¶</a></h4>
<ul>
<li>
<p>assign priorities to the pending requests and to serve the requests in priority order</p>
</li>
<li>
<p>Result: worsk-case latency = the worst-case service time of all the other devices + the service time of all higher-priority devices</p>
<p>当前运行的程序完成后才会运行下一个（在不支持中断的系统中）。</p>
</li>
<li>
<p>Subproblem: How should priorities be assigned given hard real-time constraints?</p>
<ul>
<li>
<p>assume each device has a service deadline D after the arrival of its service request. assume D is the time until the <em>next</em> request for the same device.</p>
</li>
<li>
<p>Strategy: earliest deadline, therefore highest priority = earliest deadline</p>
<blockquote>
<ol>
<li>
<p>Sort the requests by their deadlines.</p>
</li>
<li>
<p>Assign the highest priority to the earliest deadline, second priority to the next deadline, and so on.</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>
<p>例子：机场候机排序，优先让飞机快要起飞的乘客候机虽然会延迟部分乘客的候机时间，但是会减少延误的次数。但是如果系统过载，让最先要起飞的乘客优先候机会导致所有人都延误，在这个场景中排序优先问题需要重新讨论，因为目标变成了能够使延误航班次数最少的排序优先。</p>
</li>
<li>
<p>downside：the worst-case latency for a device always includes the maximum time we have to wait for the currently-running task to complete.</p>
<blockquote>
<p>Scenario: suppose disk requests have a 800 us deadline in order to guarantee the best throughput from the disk subsystem. Since the disk handler service time is 500 us, the maximum allowable latency between a disk request and starting to execute the disk service routine is 300 us.</p>
</blockquote>
<img src="/sg/2021/11/04/6.004-vm/sc5.png" class title="截屏2021-11-04 下午12.57.13">
</li>
</ul>
<h4><span id="gt-strategy2-the-need-for-preemption">&gt; Strategy2: the need for preemption</span><a href="#gt-strategy2-the-need-for-preemption" class="header-anchor">¶</a></h4>
<p>-&gt;a preemptive priority system/“strong” priority system</p>
<p>怎么处理strategy1中的场景问题？</p>
<p>设定新的优先级排序为：disk &gt; printer&gt; keyboard，改变的是当请求发出时立刻执行当前程序而不等待更低优先级程序的完成。在强优先级系统中，优先级和ddl非常相关，所以一定能在限期完成请求；而在弱优先系统中，优先级按照服务需要完成的时间划分，所以在考虑中断延迟时需要考虑其他服务的中断延迟时间。</p>
<p>…跳过了硬件实现部分…</p>
<h4><span id="gt-recurring-interrupts">&gt; recurring interrupts</span><a href="#gt-recurring-interrupts" class="header-anchor">¶</a></h4>
<p>Consider interrupts which recur at bounded rates:</p>
<img src="/sg/2021/11/04/6.004-vm/sc6.png" class title="截屏2021-11-04 下午1.16.28">
<p>Keyboard handler doesn’t complete until 3 ms after its request was received.</p>
<p>由于只要有优先级高于键盘的请求，就必须先执行那个程序。所以在实时系统中用ddl作为约束而不是延迟时间的长短。</p>
<p>面临的问题：当键盘ddl在3ms之前时，强优先系统仍然无法达到实时条件的限制，这时说明在紧张的ddl下没有足够的cpu周期达到对服务的重复要求。</p>
<img src="/sg/2021/11/04/6.004-vm/sc7.png" class title="sc7">
<p>calculations of recurring interrupts</p>
<ul>
<li>
<p>how much load each periodic request places on the system?</p>
<ul>
<li>Service time * max frequency = Load%</li>
<li>User-mode share</li>
</ul>
</li>
<li>
<p>whether have enough CPU cycles to meet each of the deadlines?</p>
<ul>
<li>example: for disk: 500/800=67.5% of the cycles to service the disk in the time between the disk request and disk deadline.</li>
</ul>
</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/sg/">Home</a></li>
         
          <li><a href="/sg/about/">About</a></li>
         
          <li><a href="/sg/categories/">Category</a></li>
         
          <li><a href="/sg/archives/">Writing</a></li>
         
          <li><a href="/sg/CV/">CV</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">17 virtual memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">Virtual memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.1.</span> <span class="toc-text">&gt; MMU:translate VA to PA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.2.</span> <span class="toc-text">&gt; Where to store page map:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.3.</span> <span class="toc-text">&gt; sum up: MMU address translation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Virtual machine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">18 virtualizing the processor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">build a VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">进程如何复用cpu？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">interrupts to time-sharing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">exception handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.5.</span> <span class="toc-text">Communicate with os</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">19 devices and interrupts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">Interrupt-based asynch I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">Implementations of ReadKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">Time-sharing can’t meet with ddl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text">the need for real time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text">Real-time scenarios</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.1.</span> <span class="toc-text">&gt; Stragegy0:  first-come-first-served scenario.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.2.</span> <span class="toc-text">&gt; Strategy1: “nonpreemptive” &#x2F; “weak” priority system.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.3.</span> <span class="toc-text">&gt; Strategy2: the need for preemption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.4.</span> <span class="toc-text">&gt; recurring interrupts</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&text=4 virtual memory"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&is_video=false&description=4 virtual memory"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=4 virtual memory&body=Check out this article: https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&title=4 virtual memory"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&name=4 virtual memory&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sgzerolc.github.io/sg/2021/11/04/6.004-vm/&t=4 virtual memory"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Sam Li
  </div>
</footer>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/sg/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
