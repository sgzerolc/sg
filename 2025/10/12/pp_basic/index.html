<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Parallelism for Efficiency Multi-core Processors  SIMD H&#x2F;W Multi-threading Bandwidth Abstraction vs. Implementation   PP Basics Performance Optimization  Work Distribution Scheduling Fork-join Prog">
<meta property="og:type" content="article">
<meta property="og:title" content="Speeding Up Parallel Programs">
<meta property="og:url" content="https://sgzerolc.github.io/sg/2025/10/12/pp_basic/index.html">
<meta property="og:site_name" content="steins gate zero">
<meta property="og:description" content="Parallelism for Efficiency Multi-core Processors  SIMD H&#x2F;W Multi-threading Bandwidth Abstraction vs. Implementation   PP Basics Performance Optimization  Work Distribution Scheduling Fork-join Prog">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2025/10/12/pp_basic/Screenshot-8140435.png">
<meta property="og:image" content="https://sgzerolc.github.io/sg/2025/10/12/pp_basic/Screenshot-8137961.png">
<meta property="article:published_time" content="2025-10-11T22:00:00.000Z">
<meta property="article:modified_time" content="2025-10-13T19:49:57.437Z">
<meta property="article:author" content="Sam Li">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sgzerolc.github.io/sg/2025/10/12/pp_basic/Screenshot-8140435.png">
    
    
      
        
          <link rel="shortcut icon" href="/sg/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/sg/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/sg/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Speeding Up Parallel Programs</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/sg/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/sg/">Home</a></li><!--
     --><!--
       --><li><a href="/sg/about/">About</a></li><!--
     --><!--
       --><li><a href="/sg/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/sg/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/sg/CV/">CV</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/sg/2025/12/25/travel_ja_25/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/sg/2025/10/01/wk_io_queue/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&text=Speeding Up Parallel Programs"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&is_video=false&description=Speeding Up Parallel Programs"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Speeding Up Parallel Programs&body=Check out this article: https://sgzerolc.github.io/sg/2025/10/12/pp_basic/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&name=Speeding Up Parallel Programs&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&t=Speeding Up Parallel Programs"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Parallelism for Efficiency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Multi-core Processors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">H&#x2F;W Multi-threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">Bandwidth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">Abstraction vs. Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">PP Basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Performance Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">Work Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">Scheduling Fork-join Programs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.3.</span> <span class="toc-text">Memory Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.4.</span> <span class="toc-text">Communication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.5.</span> <span class="toc-text">Performance Analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ISPC Basics</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Speeding Up Parallel Programs
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Sam Li</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-10-11T22:00:00.000Z" itemprop="datePublished">2025-10-12</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/sg/categories/machine-learning/">machine learning</a> › <a class="category-link" href="/sg/categories/machine-learning/cs-149-parallel-programming/">cs 149 parallel programming</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <div class="toc">
<!-- toc -->
<ul>
<li><a href="#parallelism-for-efficiency">Parallelism for Efficiency</a></li>
<li><a href="#multi-core-processors">Multi-core Processors</a>
<ul>
<li><a href="#simd">SIMD</a></li>
<li><a href="#h-w-multi-threading">H/W Multi-threading</a></li>
<li><a href="#bandwidth">Bandwidth</a></li>
<li><a href="#abstraction-vs-implementation">Abstraction vs. Implementation</a></li>
</ul>
</li>
<li><a href="#pp-basics">PP Basics</a></li>
<li><a href="#performance-optimization">Performance Optimization</a>
<ul>
<li><a href="#work-distribution">Work Distribution</a></li>
<li><a href="#scheduling-fork-join-programs">Scheduling Fork-join Programs</a></li>
<li><a href="#memory-models">Memory Models</a></li>
<li><a href="#communication">Communication</a></li>
<li><a href="#performance-analysis">Performance Analysis</a></li>
</ul>
</li>
<li><a href="#ispc-basics">ISPC Basics</a></li>
</ul>
<!-- tocstop -->
</div>
<p>Terminology:</p>
<ol>
<li>
<p>CPU clock cycle: one tick of the processor core’s clock.</p>
</li>
<li>
<p>Superscalar execution: processor automatically finds independent instructions in an instruction sequence and can execute them in parallel on multiple execution units. A two-way superscalar core can run two indepent scalar instructions per clock.</p>
</li>
<li>
<p>SM = Streaming Multiprocessor, the compute block in NVIDIA GPUs.</p>
</li>
<li>
<p>Transistors increase sophistication of processor logic that accelerates a single instruction stream of a processor. More transistors indicate larger cache, smarter out-of-order logic, smarter branch predictor, etc.</p>
</li>
<li>
<p>One core means one instruction stream.</p>
</li>
<li>
<p>ALU is an execution unit.</p>
</li>
<li>
<p>SIMD, single instruction, multiple data. It is the execution unit inside a single hardware context. Same instruction is broadcast to all ALUs, This operation is executed in parallel on all ALUs.</p>
</li>
<li>
<p>8-wide SIMD means a single SIMD instruction operates on 8 data lanes in parallel. A SIMD vector register holds 8 elements (the lanes). One instruction (e.g. add, multiply) performs the operation on all 8 lanes simultaneously. 8 lanes of 32-bit floats are 8 × 32 = 256 bits wide.</p>
<p>Example: <strong>v</strong> = <strong>a</strong> + <strong>b</strong>.  The hardware does <strong>v</strong>[i] = <strong>a</strong>[i] + <strong>b</strong>[i] for i = 0…7 in one instruction cycle depending on throughput/latency.</p>
</li>
<li>
<p>A mask is a bit vector that tells the SIMD processor which lanes should be active for a given instruction. In an 8-wide SIMD unit, you get an 8-bit mask where each bit controls one SIMD lane.</p>
</li>
<li>
<p>Instruction stream coherence (coherent instruction): the same instruction sequence applies to many data elements. It is at the level of one core for SIMD processing.</p>
</li>
<li>
<p>divergent execution: a lack of instruction stream coherence in a program.</p>
</li>
<li>
<p>explicit SIMD: SIMD parallelization is performed at compile time.</p>
</li>
<li>
<p>Implicit SIMD: h/w is responsible for execution.</p>
</li>
<li>
<p>SMT, Simultaneous multi-threading. Each clock, core chooses instructions from multiple threads to run on ALUs.</p>
</li>
<li>
<p>GPU SIMT, single instruction, multiple threads.</p>
</li>
<li>
<p>Memory bandwidth: The rate at which the memory system can provide data to a processor</p>
</li>
<li>
<p>Compute-bound: a task, job or process is said to be CPU-bound (or compute-bound) when the time it takes for it to complete is determined principally by the speed of the central processor.</p>
</li>
<li>
<p>SPMD: single program multiple data</p>
</li>
<li>
<p>ISPC is short for Implicit SPMD Program Compiler</p>
</li>
<li>
<p>Advanced Vector Extensions (AVX) are SIMD extensions to the x86 instruction set architecture for microprocessors from Intel and Advanced Micro Devices (AMD).</p>
</li>
<li>
<p>parallel slack = ratio of independent work to machine’s parallel execution capability (in practice: ~8 is a good ratio)</p>
</li>
</ol>
<h2><span id="parallelism-for-efficiency">Parallelism for Efficiency</span><a href="#parallelism-for-efficiency" class="header-anchor">¶</a></h2>
<p>The reason why we need parallelism is that power limits CPU clock frequency. Instruction level parallelism at processors is tapped out.</p>
<p>Big concerns in computing are:</p>
<p>power = heat/battery. It’s common requirements to run a program for a longer time or run with higher performance for a fixed time. If a chip gets too hot, it must be clocked down to cool off.</p>
<p>Parallel programming aims for three aspects:</p>
<ol>
<li>design at scale. Communication cost (synchronization) is a big factor at times.</li>
<li>h/w implementation:  the characteristics of the machine matter to efficiency and performance</li>
<li>h/w efficiency: fast != efficiency. The evaluation is based on performance/cost.</li>
</ol>
<p>Parallel to scheduling respects program order.</p>
<p>Cache is faster than DRAM. Caches are implemented in SRAM.</p>
<p>Cache operates at the granularity of cache lines. It means if the byte loading is not present in the cache, CPU requests the entire cache line where the byte resides starting at the cache line boundary. Common cache line size is 64 bytes.</p>
<p>Memory access time in another words is latency. A DRAM access is typically ~50–300 times slower in latency than an L1 access.</p>
<p>Data movement has high energy cost.</p>
<blockquote>
<p>Rule of thumb in modern system design: always seek to reduce amount of data movement in a computer.</p>
</blockquote>
<h2><span id="multi-core-processors">Multi-core Processors</span><a href="#multi-core-processors" class="header-anchor">¶</a></h2>
<p>A modern multi-core processor increases parallelism in many aspects:</p>
<ol>
<li>Superscalar: ILP improvements. Executes up to two instructions per clock from a single instruction stream, which is about instruction throughput.</li>
<li>Multi-core: Add more cores (processing units). Executes one instruction per clock … on each core.</li>
<li>SIMD (within a core): Add execution units (ALUs) to increase compute capability. Executes one 8-wide SIMD instruction per clock …</li>
</ol>
<p>Instructions are generated by the compiler. That means parallelism is inferred by compilers.</p>
<img src="/sg/2025/10/12/pp_basic/Screenshot-8140435.png" class title="Screenshot-8140435">
<h3><span id="simd">SIMD</span><a href="#simd" class="header-anchor">¶</a></h3>
<p>Problem: Think of piece of code that yields the worst case performance on a processor with 8-wide SIMD execution. Hint: use only a single “if” statement</p>
<p>For conditional execution, SIMD processors have to execute both branches when there’s divergence, then mask out the incorrect results. After branch, SIMD processors continue at full performance.</p>
<p>The worst case is 1/8 peak performance. We can use 1/7 split to degrade SIMD utilization to 1/8. Fro example, <code>if i == 0</code>. The key is actually utilization of resources.</p>
<p>Reduce memory access latency by many ways:</p>
<ol>
<li>Caches reduce length of stalls.</li>
<li>Data prefetching reduces stalls (hides latency). Many modern CPUs have logic for guessing what data will be accessed in the future and “pre-fetching” this data into caches. Pre-fetching can also reduce performance if the guess is wrong, which consumes bandwidth and pollutes caches.</li>
<li>Multi-threading reduces stalls. Interleave processing of multiple threads (Hardware-supported multi-threading) on the same core to hide stalls.</li>
</ol>
<h3><span id="h-w-multi-threading">H/W Multi-threading</span><a href="#h-w-multi-threading" class="header-anchor">¶</a></h3>
<blockquote>
<p>Key idea of throughput-oriented systems: Potentially increase time to complete work by any one thread, in order to increase overall system throughput when running multiple threads.</p>
</blockquote>
<p>The cost of storing execution contexts: Assume on-chip storage of execution contexts as a finite resource, how many threads can achieve 100% utilization of one core?</p>
<p>A processor with multiple h/w threads can avoid stalls by performing instructions on another thread when a thread takes a long latency operation to complete. The processor utilization is no longer reduced by the long running thread.</p>
<p>Programs that feature more arithmetic per memory access need fewer threads to hide memory stalls.</p>
<p>Architecture of a modern processor is a multi-core chip with multi-threaded, superscalar cores. It can be:</p>
<p>16 core/ 8 SIMD ALUs per core/4 (h/w) threads per core.</p>
<img src="/sg/2025/10/12/pp_basic/Screenshot-8137961.png" class title="one_core">
<p>-&gt; 16 simultaneous instruction streams / 64 total concurrent instruction streams / 512 independent pieces of work to run chip with maximal latency hiding ability</p>
<p>For example, one SM unit of a NVIDIA GPU can be:</p>
<p>64 “warp” execution contexts per SM / Wide SIMD:  16-wide SIMD ALUs (carry out 32-wide SIMD execute over 2 clocks)</p>
<p>-&gt; 2048 data items processed concurrently per “SM” core</p>
<p>One GPU can have 80 SM cores.</p>
<p>GPU SIMT: modern GPUs excute hardware threads running only scalar instructions. GPU cores implement simultaneous execution of SIMD-width threads when they are executing the same instruction. A divergent thread would be masked off.</p>
<p>Applications for utilizing modern processors efficiently must:</p>
<ol>
<li>Utilize all available execution units across many cores and many execution units (ALUs) on one core</li>
<li>Groups of parallel work items must require the same sequences of instructions to utilize SIMD execution</li>
<li>Expose more parallel work than processor ALUs to enable interleaving of work to hide memory stalls</li>
</ol>
<h3><span id="bandwidth">Bandwidth</span><a href="#bandwidth" class="header-anchor">¶</a></h3>
<p>Memory bandwidth is a rate at which data is transferred from memory to a processor.</p>
<p>A bandwidth limited computation is that the bandwidth of the memory system cannot keep up the rate processors request data.</p>
<p>Problem: how to overcome bandwidth limits?</p>
<blockquote>
<p>Programs must access memory infrequently to utilize modern processors efficiently.</p>
</blockquote>
<p>Reducing memory accesses:</p>
<p>Reuse data loaded by the same thread and share data across threads. Example: perform math to storing values.</p>
<p>Fun fact: modern CPUs may contain up to 20 stages in their instruction pipeline.</p>
<p>GPU may not be used more efficiently than CPU. But it’s faster than CPU for throughput workloads. GPUs are built for data-parallel work and much higher memory bandwidth, so for massively parallel floating-point tasks (matrix multiply, convolutions, large vector operations, dense linear algebra) they can be orders of magnitude faster than a CPU.</p>
<h3><span id="abstraction-vs-implementation">Abstraction vs. Implementation</span><a href="#abstraction-vs-implementation" class="header-anchor">¶</a></h3>
<p>Abstraction: semantics of operations provided by a programming model. What are expected from the program to compute?</p>
<p>Implementation: scheduling of parallel programs. How will the program actually compute on a parallel machine?</p>
<p>Our goal: A parallel programming model implementations -&gt; Trace through what each part of parallel computer is doing during each step of program.</p>
<p>SPMD is the programming abstraction for ISPC Programming (parallel programming). And SIMD implementations handle mappings of conditional control flows to vector instructions. Masking vector lanes is one example.</p>
<ul>
<li>SPMD programming abstraction: An ISPC function spawns gangs of ISPC programming instances which run ISPC code concurrently. Each instance has its local copy of variables. Upon return, all instances have completed.</li>
<li>ISPC compiler generates SIMD implementation. Number of instances in a gang is the SIMD width of the hardware (or a small multiple of SIMD width). ISPC compiler generates a C++ function binary (.o) whose body contains SIMD instructions. C++ code links against generated object file as usual.</li>
<li>An ISPC gang is implemented by SIMD instructions executing within one thread of one CPU core. An ISPC task is executed within multi-core CPU.</li>
</ul>
<p>Keywords<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>:</p>
<p><code>programCount</code>: number of simultaneously executing instances in the gang (uniform value)</p>
<p><code>programIndex</code>: id of the current instance in the gang (a non-uniform value: “varying”)</p>
<p><code>uniform</code>: A type modifier. All instances have the same value for this variable. Its use is purely an optimization. Not needed for correctness.</p>
<p><code>foreach</code> declares parallel loop iterations which the entire gang must perform</p>
<p><code>reduce_add()</code>: A cross-instance communication primitive.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Compute sum of a variable’s value in all program instances in a gang</span><br><span class="line">uniform int64 <span class="title function_">reduce_add</span><span class="params">(int32 x)</span>;</span><br><span class="line"># Compute the min of all values in a gang:</span><br><span class="line">uniform int32 <span class="title function_">reduce_min</span><span class="params">(int32 a)</span>;</span><br><span class="line"># Broadcast a value from one instance to all instances in a gang:</span><br><span class="line">int32 <span class="title function_">broadcast</span><span class="params">(int32 value, uniform <span class="type">int</span> index)</span>;</span><br><span class="line"># For all i, pass value from instance i to the instance i+offset % programCount:</span><br><span class="line">int32 <span class="title function_">rotate</span><span class="params">(int32 value, uniform <span class="type">int</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>ISPC implementation takes responsibility for assigning iterations to program instances in the gang.</p>
<p>Scheduling: map iterations to program instances</p>
<ol>
<li>Blocked assignment of program instances to loop iterations: If the SIMD width is eight, divide iterations to eight groups and assign each program instance sum/eight iterations. For all program instances in the gang, the #programCount values of the same index are not contiguous in memory, which require a costly gather instruction to fetch values.</li>
<li>Interleaved assignment: assign each program instance one iteration one by one. For all program instances in the gang, the #programCount values are contiguous in memory, which can be implemented by a <code>packed vector load</code> instruction.</li>
<li>Dynamic assignment: assign new work depending on the status of other program instance</li>
<li>Fixed assignment: for example, always assign one program instance all iterations</li>
</ol>
<p>It’s a bad scenario where multiple iterations of the loop body write to same memory location. The output of such a program is undefined.</p>
<h2><span id="pp-basics">PP Basics</span><a href="#pp-basics" class="header-anchor">¶</a></h2>
<p>Amdahl’s law: the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.</p>
<p>Let S be the fraction of work that is inherently sequential. The rest of work that can be parallel is (1-S).</p>
<p>Max speedup on P processors: speedup &lt;= 1 / [(1-S)/P + S] &lt;= 1/S</p>
<p>Dependencies prevent parallel execution. A small serial region can limit speedup on a large parallel machine where the speedup is 1/S as P &gt;&gt; S.</p>
<p>A parallel problem can be divided into four parts: decomposition, assignment, orchestration and mapping to hardware.</p>
<ul>
<li>Decomposition is breaking up problem into tasks that can be run in parallel and identifying dependencies of tasks.</li>
<li>Assignment is assigning tasks to workers (threads) to achieve a good workload balance and reduce communication costs.</li>
<li>Orchestration involves synchronization, scheduling and communication.</li>
<li>Mapping to hardware is mapping workers to hardware execution units.</li>
</ul>
<p>There are two ways to solve a parallel problem. Data-parallel model supports hardware dependent intrinsics, exposing special built-in primitives to synchronize or communicate. For example, the <code>forall</code> loop has an implicit barrier at the end of the body. Shared address space model is generally used not just in parallel problems.</p>
<ol>
<li>Data-parallel programming model.</li>
<li>Shared address space/SPMD. It’s usually used in multi-threaded programs. Locks express mutual exclusion for shared variables. Barriers express dependencies of computation phases they divide into.</li>
</ol>
<p>Barriers are used for dependent phases of computation. Each processor has its own private memory. Processors need to be synchronized to share data. All computation by all threads before the barrier complete before any computation in any thread after the barrier begins.</p>
<h2><span id="performance-optimization">Performance Optimization</span><a href="#performance-optimization" class="header-anchor">¶</a></h2>
<p>Optimizing performance of parallel programs has misaligned goals:</p>
<ul>
<li>Balance workload onto execution resources</li>
<li>Reduce communication cost</li>
<li>Reduce overhead of orchestration</li>
</ul>
<p>Parallel programming rules of thumb: We want at least as much independent work as the parallel execution capability allows, preferably more. But the work should not be too much so that granularity of work is too small.</p>
<p>In general, fine-grained work incurs overhead of management while coarse-grained work incurs load imbalance.</p>
<p>Summary of Tips:</p>
<ol>
<li>Implement the simplest solution first, then measure performance to determine room for improvement.</li>
<li>Establish high watermarks for your program.</li>
<li>Be aware of scaling issues.</li>
</ol>
<h3><span id="work-distribution">Work Distribution</span><a href="#work-distribution" class="header-anchor">¶</a></h3>
<p>To achieve good workload balance, we want all processors working but low-cost of communication and orchestration (synchronization).</p>
<p>Work assignments can be classified as static, semi-static or dynamic. Choosing between static or dynamic depends on system knowledge of workload so as to reduce load imbalance and synchronization costs.</p>
<p>Static: Assignment of work to threads does not depend on dynamic behavior. The assignment is static when the assignment is determined given the amount of work and number of workers. It may depend on runtime parameters such as input data size. But statistics about execution time are predictable.</p>
<p>Semi-static: Cost of work is predictable for near-term future. Application periodically profiles its execution and re-adjusts assignment.</p>
<p>Dynamic: Assignment of work is determined dynamically at runtime to ensure a well-distributed load.</p>
<h3><span id="scheduling-fork-join-programs">Scheduling Fork-join Programs</span><a href="#scheduling-fork-join-programs" class="header-anchor">¶</a></h3>
<p>Fork-join pattern is natural to express divide-and-conquer algorithms. The examples are in <a target="_blank" rel="noopener" href="https://www.opencilk.org/">Cilk Plus</a>. A fork is creating new logical thread of control. A join is syncing up with the spawned calls.</p>
<p><code>cilk_spawn foo(args);</code></p>
<p>Caller may continue executing asynchronously with execution of <code>foo</code>.</p>
<p><code>cilk_sync;</code></p>
<p>An implicit cilk_sync is at the end of every function containing a cilk_spawn.</p>
<p>Main idea is to expose independent work to the system using forks. Scheduling may incur performance problems like heavyweight spawns, context switching overhead, larger working set than necessary.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># spawned child</span><br><span class="line">cilk_spawn foo();</span><br><span class="line"># continuation</span><br><span class="line">bar();</span><br><span class="line">cilk_sync();</span><br></pre></td></tr></table></figure>
<p>Cilk’s implementation of thread pool. The Cilk runtime maintains pool of worker threads. It’s exactly one execution context for one worker thread in the machine. Per-thread work queues store work to do. Thread continually pops continuation from work queue, enqueues new continuation. Idle threads steal work from busy threads.</p>
<p>Calling thread can run the child or the continuation at spawn.</p>
<ol>
<li>Run continuation first: queue child for later execution which is available for stealing by other threads (child stealing).
<ul>
<li>Caller thread spawns work for all iterations before any execution.</li>
<li>Breadth-first traversal of call graph. O(N) space (N is problem size)</li>
<li>Without stealing, different execution order from the same program without spawning children.</li>
</ul>
</li>
<li>Run child first: enqueue continuation for later execution (continuation stealing).
<ul>
<li>Caller thread creates one item of all remaining iterations to steal and executes current iteration.</li>
<li>Depth-first traversal of call graph. Same execution order when no stealing.</li>
<li>Space. Work queue storage for system with T threads is no more than T times that of stack storage for single threaded execution</li>
</ul>
</li>
</ol>
<p>Work stealing with run child first scheme implementation:</p>
<ul>
<li>Dequeue per worker: Every worker has a work queue. Work queue is implemented as a dequeue (double ended queue). Local thread pushes/pops from the tail (bottom). Remote threads steal from head (top).</li>
<li>Choice of victim: Steal work from top of dequeue. The top element of work queue has largest amount of work. In this way, each thread can perform work with maximum locality. Stealing thread and local thread do not contend for same elements of dequeue when dequeue applies lock-free scheme.</li>
</ul>
<p>Greedy join scheduling. All threads always attempt to steal if there is nothing to do. They go idle only if there is no work to steal. The worker thread executes logic after cilk_sync may be different from thread that initiated spawn.</p>
<p>Sync implementation:</p>
<p>Without stealing, there is nothing to do at sync point.</p>
<p>For stealing case, Cilk uses descriptors to bookkeep steals and sync points. The descriptor tracks the number of outstanding spawns for the section, and the number of those spawns that have completed.</p>
<h3><span id="memory-models">Memory Models</span><a href="#memory-models" class="header-anchor">¶</a></h3>
<p>There are two memory models. One is shared address space model where threads communicate by reading and writing to variables in shared address space. The other is message passing model where threads operate within their own private address spaces. Shared address space model requires hardware support to implement a single shared address space for all processors. In contrast, message passing model does not have such requirements. It only needs to provide communication mechanisms between nodes, which makes it easier to connect commodity systems to form a large parallel machine for clusters and supercomputers.</p>
<p>Non-uniform memory access (NUMA): The latency of accessing a memory location may be different from different processing cores in the system. Bandwidth from any one location may also be different to different CPU cores. In practice, NUMA behavior can also be found on a single-socket system since different cache slices are a different distance from each core.</p>
<p>Shared address space hardware architecture: any processor can directly reference any memory location. It can be costly to scale to large numbers of processors, increasing communication cost.</p>
<p>Message passing model: sending messages is the only way to exchange data between threads. The communication interface is <code>send(dest, buffer, msg_id)</code> and <code>recv(sender, buffer, msg_id)</code>.</p>
<p>Message passing can be synchronous (blocking) and asynchronous (non-blocking).</p>
<ol>
<li>Synchronous (blocking): calls return when caller receives acknowledgement that message data resides in address space of callee</li>
<li>Asynchronous (non-blocking): calls return immediately. Use checksend(), checkrecv() to determine actual status of send/receipt.</li>
</ol>
<h3><span id="communication">Communication</span><a href="#communication" class="header-anchor">¶</a></h3>
<p>A parallel system can be viewed as an extended memory hierarchy. The lower the level, the higher the latency, the lower the bandwidth, and the larger the capacity.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Processor:</span><br><span class="line">- Reg</span><br><span class="line">- Local L1 cache</span><br><span class="line">- Local L2</span><br><span class="line">- L2 from another core</span><br><span class="line">- L3</span><br><span class="line">- Local memory</span><br><span class="line">- Remote memory (1 network hop)</span><br><span class="line">- Remote memory (N network hops)</span><br></pre></td></tr></table></figure>
<p>Communication refers to not only messages between machines. It also refers to messages between a processor and its cache, between processor and memory, or between processor and a remote memory. Non-local memory accesses result in communication with other levels. Managing locality to reduce the amount of communication performed is important at all levels.</p>
<p><strong>Arithmetic intensity</strong> = amount of computation (e.g., instructions) / amount of communication (e.g., bytes)</p>
<p><code>1/Arithmetic intensity</code> is communication-to-computation ratio.</p>
<p>High arithmetic intensity is required to utilize modern processors.</p>
<p>There are two reasons for communication:</p>
<ol>
<li>Inherent communication: Communication that must occur in a parallel algorithm. Good assignment decisions can reduce inherent communication</li>
<li>Artifactual communication: all other communication. It results from system implementations such as cache line size. Recall that when a program load a variable, entire cache line must be transferred from memory. For examples, a system may have minimum granularity of data transfer, causing unnecessary communication. System operation might result in unnecessary communication (store, load, overwrite, store). A system may have finite replication capacity (capacity miss).</li>
</ol>
<p>A resource can perform operations at a given throughput (number of transactions per unit time). Contention occurs when many requests to a resource are made within a small window of time (the resource is a “hot spot”).</p>
<p>Techniques for reducing communication:</p>
<ol>
<li>Reduce overhead of communication to sender/receiver
<ul>
<li>Send fewer messages, make messages larger (amortize overhead)</li>
<li>Coalesce small messages into large ones</li>
</ul>
</li>
<li>Reduce latency of communication
<ul>
<li>s/w: restructure code to exploit locality. For example, change array traversal order to fit cache capacity.</li>
<li>h/w:  improve communication architecture</li>
</ul>
</li>
<li>Reduce contention
<ul>
<li>Replicate contended resources: local copies, fine-grained locks</li>
<li>Stagger access to contended resources.</li>
<li>For example, distributed work queues reduce contention in access to single shared work queue.</li>
</ul>
</li>
<li>Increase communication/computation overlap
<ul>
<li>s/w: async messages</li>
<li>h/w: pipelining, multi-threading, pre-fetching, out-of-order exec</li>
</ul>
</li>
</ol>
<h3><span id="performance-analysis">Performance Analysis</span><a href="#performance-analysis" class="header-anchor">¶</a></h3>
<p>A strategy is to try and establish high watermarks. Try to find out what’s the best performance in practice, which tells you how close your implementation to a best-case scenario. Determine if your performance is limited by computation, memory bandwidth (or memory latency), or synchronization?</p>
<p>Roofline model is a plot whose X axis corresponds to arithmetic intensities (memory bandwidth) and whose Y axis corresponds to maximum obtainable instruction throughput (compute). It depicts optimization regions.</p>
<p>To establish high watermarks, there are some techniques to show how compute, bandwidth or sync affect execution time of a program. Although overall performance is influenced by many factors, the performance change to the program modifications can be a good indication of dominant costs.</p>
<ul>
<li>Add math (non-memory instructions)</li>
<li>Remove almost all math, but load same data</li>
<li>Change all array accesses to A[0]</li>
<li>Remove all atomic operations or locks</li>
</ul>
<p>Use profilers/performance monitoring tools. All modern processors have low-level event “performance counters”. Registers that count important details such as: instructions completed, clock ticks, L2/L3 cache hits/misses, bytes read from memory controller, etc.</p>
<p>Understanding problem size issues</p>
<ol>
<li>Speedup should be measured against the performance of the best sequential program, not a parallel version of a program running on single processor.</li>
<li>Evaluating a machine with a fixed problem size can be problematic. Problem size that is too small for the machine leads to a large communication-to-computation ratio. If problem size is too large for a single machine, working set may not fit in memory, causing thrashing to disk. Super-linear speedups can occur on a bigger parallel machine where the working set can fit in memory.</li>
<li>Scaling problem size can be desirable as machine sizes grow. Buy a bigger machine to compute more, rather than just compute the same problem faster</li>
</ol>
<h2><span id="ispc-basics">ISPC Basics</span><a href="#ispc-basics" class="header-anchor">¶</a></h2>
<p>compile a program:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ispc (--target=avx2-x8) -O2 -h simple_ispc.h -o simple_ispc.obj simple.ispc</span><br><span class="line"></span><br><span class="line">g++ -O2 main.cpp simple_ispc.o -o simple_app</span><br><span class="line"><span class="comment"># Or compile host C++ code and link afterwards</span></span><br><span class="line">g++ -O2 -c main.cpp -o main.o</span><br><span class="line">g++ main.o simple_ispc.o -o simple_app</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(GPT-5t-mini) <code>--target=avx2-x8</code> — choose the code-generation target.<br>
This picks an x86 AVX2 codepath and a gang/vector width. ISPC historically uses names like <code>avx2-i32x8</code> to mean “AVX2 target with 32-bit base types and 8 lanes” (i.e. 8 program instances / SIMD lanes). Older short forms like <code>avx2-x8</code> are still accepted by some ISPC builds, but the explicit form <code>avx2-i32x8</code> is clearer and recommended. The gang width determines how many ISPC program instances run in lockstep (and usually maps to SIMD lanes).</p>
<p><code>-O2</code> — optimization level (optimize for speed).</p>
<p><code>-h simple_ispc.h</code> — generate a C header file (<code>simple_ispc.h</code>) with the C-callable function declarations that match your ISPC <code>export</code> functions.</p>
<p><code>-o simple_ispc.obj</code> — write the compiled object file with this name. On Linux/macOS you’d typically use <code>.o</code> (e.g. <code>simple_ispc.o</code>); on Windows/MSVC use <code>.obj</code>.</p>
<p><code>simple.ispc</code> — the input ISPC source file.</p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://ispc.github.io/perfguide.html">https://ispc.github.io/perfguide.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/sg/">Home</a></li>
         
          <li><a href="/sg/about/">About</a></li>
         
          <li><a href="/sg/categories/">Category</a></li>
         
          <li><a href="/sg/archives/">Writing</a></li>
         
          <li><a href="/sg/CV/">CV</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Parallelism for Efficiency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Multi-core Processors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">H&#x2F;W Multi-threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">Bandwidth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">Abstraction vs. Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">PP Basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Performance Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">Work Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">Scheduling Fork-join Programs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.3.</span> <span class="toc-text">Memory Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.4.</span> <span class="toc-text">Communication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.5.</span> <span class="toc-text">Performance Analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ISPC Basics</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&text=Speeding Up Parallel Programs"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&is_video=false&description=Speeding Up Parallel Programs"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Speeding Up Parallel Programs&body=Check out this article: https://sgzerolc.github.io/sg/2025/10/12/pp_basic/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&title=Speeding Up Parallel Programs"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&name=Speeding Up Parallel Programs&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sgzerolc.github.io/sg/2025/10/12/pp_basic/&t=Speeding Up Parallel Programs"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Sam Li
  </div>
</footer>


    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/sg/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
